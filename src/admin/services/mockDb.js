
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey || supabaseUrl.includes('YOUR_SUPABASE_URL')) {
    const msg = 'CRITICAL ERROR: Supabase credentials missing or default in .env file. Please update .env with real keys and RESTART SERVER.';
    console.error(msg);
    alert(msg);
    throw new Error(msg);
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// Helper to map Supabase product result to frontend structure
const mapProduct = (p) => {
    let features = [];
    try {
        features = p.features ? JSON.parse(p.features) : [];
    } catch (e) {
        // Fallback if it's just a string
        features = p.features ? [p.features] : [];
    }

    // Extract category_id from joined sub_category if available
    const categoryId = p.sub_categories?.category_id || p.category_id;

    return {
        ...p,
        id: p.id,
        category: categoryId, // Mapped for frontend
        subcategory: p.sub_category_id, // Mapped for frontend
        features: Array.isArray(features) ? features : [features],
        images: p.product_images ? p.product_images.map(img => img.image_url) : [],
        is_featured: p.is_featured, // Pass through
        sub_category_id: undefined, // Cleanup
        product_images: undefined,   // Cleanup
        sub_categories: undefined    // Cleanup
    };
};

class SupabaseDatabase {
    constructor() {
        console.log('Supabase Database Service Initialized (Schema V2)');
    }

    // --- Categories ---
    async getCategories() {
        const { data, error } = await supabase
            .from('categories')
            .select('*')
            .order('name');

        if (error) {
            console.error('Error fetching categories:', error);
            return [];
        }
        return data;
    }

    async createCategory(catData) {
        // ID is UUID generated by DB
        const { data, error } = await supabase
            .from('categories')
            .insert([{ name: catData.name }]) // Ignore provided ID, let DB generate
            .select()
            .single();

        if (error) throw error;
        return data;
    }

    async deleteCategory(id) {
        const { error } = await supabase
            .from('categories')
            .delete()
            .eq('id', id);

        if (error) throw error;
        return true;
    }

    // --- Subcategories ---
    async getSubcategories(categoryId = null) {
        let query = supabase.from('sub_categories').select('*').order('name');

        if (categoryId) {
            query = query.eq('category_id', categoryId);
        }

        const { data, error } = await query;
        if (error) {
            console.error('Error fetching subcategories:', error);
            return [];
        }
        return data;
    }

    async createSubcategory(subData) {
        // Ensure category_id is present
        const { data, error } = await supabase
            .from('sub_categories')
            .insert([{
                name: subData.name,
                category_id: subData.category_id || subData.category // Handle both prop names
            }])
            .select()
            .single();

        if (error) throw error;
        return data;
    }

    async deleteSubcategory(id) {
        const { error } = await supabase
            .from('sub_categories')
            .delete()
            .eq('id', id);

        if (error) throw error;
        return true;
    }

    // --- Products ---
    async getProducts(page = 1, limit = 20, search = '', filters = {}) {
        const from = (page - 1) * limit;
        const to = from + limit - 1;

        // Select products and join images. 
        // Also join sub_categories to get category_id if needed for mapping or filtering
        let query = supabase
            .from('products')
            .select('*, product_images(image_url), sub_categories(category_id)', { count: 'exact' });

        if (search) {
            query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%`);
        }

        if (filters.category) {
            // Filter by category via the sub_category relationship
            // !inner is required to filter on a joined table
            query = supabase
                .from('products')
                .select('*, product_images(image_url), sub_categories!inner(category_id)', { count: 'exact' })
                .eq('sub_categories.category_id', filters.category);
        }

        if (filters.subcategory) {
            query = query.eq('sub_category_id', filters.subcategory);
        }

        const { data, error, count } = await query
            .range(from, to)
            .order('created_at', { ascending: false });

        if (error) {
            console.error('Error fetching products:', error);
            return { data: [], total: 0, page, limit };
        }

        // Map and return
        const mappedData = data.map(mapProduct);

        return {
            data: mappedData,
            total: count || 0,
            page,
            limit
        };
    }

    async getProduct(id) {
        const { data, error } = await supabase
            .from('products')
            .select('*, product_images(image_url), sub_categories(category_id)')
            .eq('id', id)
            .single();

        if (error) {
            console.error('Error fetching product:', error);
            return null;
        }

        return mapProduct(data);
    }

    async createProduct(prodData) {
        const { images, category, subcategory, features, ...rest } = prodData;

        const productPayload = {
            ...rest,
            // products table doesn't have category_id? 
            // If it does, uncomment: category_id: category,
            sub_category_id: subcategory, // Map 'subcategory' -> 'sub_category_id'
            features: JSON.stringify(features || []), // Store as JSON string in text column
            is_featured: rest.is_featured || false
        };

        // Cleaning up undefineds
        delete productPayload.id; // Allow DB to generate UUID

        const { data: product, error: prodError } = await supabase
            .from('products')
            .insert([productPayload])
            .select()
            .single();

        if (prodError) throw prodError;

        if (images && images.length > 0) {
            const imageInserts = images.map(url => ({
                product_id: product.id,
                image_url: url
            }));

            const { error: imgError } = await supabase
                .from('product_images')
                .insert(imageInserts);

            if (imgError) console.error('Error saving images:', imgError);
        }

        return this.getProduct(product.id);
    }

    async updateProduct(id, prodData) {
        const { images, category, subcategory, features, ...rest } = prodData;

        const updates = {
            ...rest,
            sub_category_id: subcategory,
            features: JSON.stringify(features || [])
        };
        // Remove helper fields
        delete updates.created_at;
        delete updates.product_images;
        delete updates.sub_categories;

        const { error: prodError } = await supabase
            .from('products')
            .update(updates)
            .eq('id', id);

        if (prodError) throw prodError;

        if (images) {
            await supabase.from('product_images').delete().eq('product_id', id);

            if (images.length > 0) {
                const imageInserts = images.map(url => ({
                    product_id: id,
                    image_url: url
                }));
                await supabase.from('product_images').insert(imageInserts);
            }
        }

        return this.getProduct(id);
    }

    async deleteProduct(id) {
        // Delete images first (if no cascade)
        await supabase.from('product_images').delete().eq('product_id', id);

        const { error } = await supabase
            .from('products')
            .delete()
            .eq('id', id);

        if (error) throw error;
        return true;
    }

    // --- Storage ---
    async uploadImage(file) {
        const folder = 'product-images';
        const fileName = `${Date.now()}-${file.name.replace(/\s+/g, '-')}`;
        const filePath = `${fileName}`;

        const { data, error } = await supabase.storage
            .from(folder)
            .upload(filePath, file);

        if (error) {
            console.error('Upload error:', error);
            throw error;
        }

        const { data: { publicUrl } } = supabase.storage
            .from(folder)
            .getPublicUrl(filePath);

        return publicUrl;
    }
}

export const db = new SupabaseDatabase();
